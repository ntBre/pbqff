









<!DOCTYPE html>
<html lang="en">
  <head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>pbqff: push-button quartic force fields</title>
	<style>
	  body {
		  width:60%;
		  margin-left: auto;
		  margin-right: auto;
	  }
	  pre {
		  word-wrap: normal;
		  overflow-x: auto;
		  background-color: rgb(245, 245, 245);
		  padding: 10px;
	  }
	  table {
		  border-collapse: collapse;
		  border: 2px solid rgb(140 140 140);
		  font-family: sans-serif;
		  font-size: 0.8rem;
		  letter-spacing: 1px;
	  }
	  caption {
		  caption-side: bottom;
		  padding: 10px;
		  font-weight: bold;
	  }
	  th, td {
		  padding: 8px 10px;
		  text-align: left;
	  }
	  h2 a, h3 a, h4 a {
		  text-decoration: none;
		  color: inherit;
	  }
	  h2 a:hover, h3 a:hover, h4 a:hover {
		  text-decoration: underline;
	  }
	</style>
  </head>
  <body>
	<h1>pbqff</h1>

	<p>
	  This page contains the complete documentation for pbqff as a single HTML
	  page. For a quick reference see
	  the <a href="https://github.com/ntBre/pbqff/tree/master/man">man</a>
	  directory in the main repository, where you can find a manual page in both
	  Unix <code>man</code> and PDF formats.
	</p>

	<h2>Table of Contents</h2>
	<ul>
	<li><a href="#introduction">Introduction</a></li>
	<li><a href="#program-input">Program Input</a></li>
	<ul>
		<li><a href="#example-input-file">Example Input File</a></li>
</ul>
	<ul>
		<li><a href="#summary-of-input-options">Summary of Input Options</a></li>
</ul>
	<ul>
	<li><a href="#geometry-specification-and-optimization">Geometry Specification and Optimization</a></li>
		<li><a href="#charge">Charge</a></li>
		<li><a href="#step-size">Step Size</a></li>
		<li><a href="#sleep-interval">Sleep Interval</a></li>
		<li><a href="#job-limit-and-chunk-size">Job Limit and Chunk Size</a></li>
	<ul>
		<li><a href="#rules-of-thumb">Rules of Thumb</a></li>
</ul>
		<li><a href="#coordinate-types">Coordinate Types</a></li>
	<ul>
		<li><a href="#cartesian-coordinates">Cartesian Coordinates</a></li>
</ul>
	<ul>
		<li><a href="#normal-coordinates">Normal Coordinates</a></li>
</ul>
	<ul>
		<li><a href="#symmetry-internal-coordinates">Symmetry-Internal Coordinates</a></li>
</ul>
		<li><a href="#quantum-chemistry-program-types">Quantum Chemistry Program Types</a></li>
		<li><a href="#queue-types">Queue Types</a></li>
		<li><a href="#quantum-chemistry-program-templates">Quantum Chemistry Program Templates</a></li>
		<li><a href="#queue-templates">Queue Templates</a></li>
		<li><a href="#derivative-types">Derivative Types</a></li>
		<li><a href="#checkpoints">Checkpoints</a></li>
		<li><a href="#atomic-masses">Atomic Masses</a></li>
		<li><a href="#dummy-atoms">Dummy Atoms</a></li>
		<li><a href="#resuming-normal-coordinate-qffs">Resuming Normal Coordinate QFFs</a></li>
	</ul>
<li><a href="#command-line-options">Command Line Options</a></li>
</ul>


	<h2 id=introduction><a href="#introduction">Introduction</a></h2>

	<p>
	  pbqff is a package (really a collection of packages) for computing
	  anharmonic vibrational and rotational spectroscopic constants for small
	  molecules. It does this through the use of quartic force fields (QFFs) to
	  approximate the molecular potential energy function and second-order
	  vibrational and rotational perturbation theory, which utilize the
	  derivative information from the function approximation to compute the
	  actual spectroscopic constants.
	</p>

	<p>
	  Because this is a complex task, pbqff is broken into several reusable
	  components, only the final piece of which is included in this repository.
	  Other major components include:
	</p>

	<ul>
	  <li>
		<a href="https://github.com/ntBre/symm">symm</a> for the
		main <code>Molecule</code> data structure and symmetry operations
	  </li>
	  <li>
		<a href="https://github.com/ntBre/psqs">psqs</a> for interfaces to
		quantum chemistry programs and distributed queuing systems
	  </li>
	  <li>
		<a href="https://github.com/ntBre/spectro">spectro</a> for the final
		spectroscopic calculations
	  </li>
	</ul>

	<p>
	  pbqff itself is a relatively thin wrapper around these packages that
	  primarily handles tasks like generating the grid of displaced geometries
	  to map out the QFF in various coordinate systems. This fact isn't really
	  important directly, but it may help to explain some of the potential error
	  messages you encounter, if they reference source code
	  in <code>psqs</code>, for example.
	</p>

	<h2 id=program-input><a href="#program-input">Program Input</a></h2>

	<p>
	  The primary input for pbqff is a <a href="https://toml.io/en/">TOML</a>
	  file. TOML as a format is widely used in the Rust community and is pretty
	  easy for humans to write, although you will end up having to type a lot of
	  quotes compared to something like YAML. To start, here's an example input
	  file for a <a href="https://github.com/openmopac/mopac">MOPAC</a> QFF on a
	  PBS queue:
	</p>

	<h4 id=example-input-file><a href="#example-input-file">Example Input File</a></h4>

	<pre><code>geometry = """
O
H 1 OH
H 1 OH 2 HOH

OH = 1.0
HOH = 109.5
"""
optimize = true
charge = 0
step_size = 0.005
sleep_int = 2
job_limit = 2048
chunk_size = 1
coord_type = "norm"
template = "scfcrt=1.D-21 aux(precision=14 comp xp xs xw) PM6 THREADS=1"
queue_template = """
#!/bin/sh
#PBS -N .basename
#PBS -S /bin/bash
#PBS -j oe
#PBS -o pts/.basename.out
#PBS -W umask=022
#PBS -l walltime=100:00:00
#PBS -l cput=100:00:00
#PBS -l ncpus=1
#PBS -l mem=16gb
#PBS -q workq

module load openpbs

export WORKDIR=$PBS_O_WORKDIR
export TMPDIR=/tmp/$USER/$PBS_JOBID
export MOPAC_PATH=/ddnlus/r2518/Packages/mopac/build/mopac
export LD_LIBRARY_PATH=/ddnlus/r2518/Packages/mopac/build
cd $WORKDIR
mkdir -p $TMPDIR
"""
program = "mopac"
queue = "slurm"
findiff = true
check_int = 0</code></pre>

	<p>
	  In addition to the options specified here, there are a few other optional
	  values like <code>hybrid_template</code> for specifying a separate quantum
	  chemistry program template for the cubic and quartic force
	  constants, <code>weights</code> for specifying atomic
	  weights, <code>dummy_atoms</code> for specifying a number of trailing
	  dummy atoms, and the very specialized <code>norm_resume_hff</code> for
	  resuming a normal coordinate QFF from the finished Cartesian harmonic
	  force field (HFF). A summary of all the possible input options is given in
	  the table below, followed by a more detailed description of each option.
	</p>

	<h4 id=summary-of-input-options><a href="#summary-of-input-options">Summary of Input Options</a></h4>

	<table>
	  <tr>
		<th>Option</th>
		<th>Type</th>
		<th>Description</th>
	  </tr>
	  <tr>
		<td><code>geometry</code></td>
		<td>String</td>
		<td>The initial molecular geometry as XYZ or Z-matrix</td>
	  </tr>
	  <tr>
		<td><code>optimize</code></td>
		<td>bool</td>
		<td>Whether or not to optimize the geometry before running the QFF</td>
	  </tr>
	  <tr>
		<td><code>charge</code></td>
		<td>isize</td>
		<td>The molecular charge</td>
	  </tr>
	  <tr>
		<td><code>step_size</code></td>
		<td>f64</td>
		<td>The displacement size for the QFF in Å</td>
	  </tr>
	  <tr>
		<td><code>sleep_int</code></td>
		<td>usize</td>
		<td>Interval in seconds to sleep between job polling iterations</td>
	  </tr>
	  <tr>
		<td><code>job_limit</code></td>
		<td>usize</td>
		<td>Maximum number of jobs to submit to the queue at once</td>
	  </tr>
	  <tr>
		<td><code>chunk_size</code></td>
		<td>usize</td>
		<td>Number of jobs to combine into a single queue submission</td>
	  </tr>
	  <tr>
		<td><code>coord_type</code></td>
		<td>CoordType</td>
		<td>Displacement type for the QFF. Supported values are sic, cart, and
		norm</td>
	  </tr>
	  <tr>
		<td><code>template</code></td>
		<td>TemplateSrc</td>
		<td>Quantum chemistry program template. Can either be a literal String
		or a map with the key <code>file</code></td>
	  </tr>
	  <tr>
		<td><code>hybrid_template</code></td>
		<td> Option&lt;TemplateSrc&gt;</td>
		<td>Separate quantum chemistry program template for cubic and quartic
		force constants</td>
	  </tr>
	  <tr>
		<td><code>queue_template</code></td>
		<td> Option&lt;TemplateSrc&gt;</td>
		<td>Queuing system template</td>
	  </tr>
	  <tr>
		<td><code>program</code></td>
		<td>Program</td>
		<td>A quantum chemistry program name. Supported values are dftb+, mopac,
		molpro, and cfour</td>
	  </tr>
	  <tr>
		<td><code>queue</code></td>
		<td> Queue</td>
		<td>A queuing system. Supported values are pbs, slurm, and local</td>
	  </tr>
	  <tr>
		<td><code>findiff</code></td>
		<td> Option&lt;bool&gt;</td>
		<td>Whether to use finite differences for derivative evaluations. Not
		all coordinate types support this</td>
	  </tr>
	  <tr>
		<td><code>check_int</code></td>
		<td>usize</td>
		<td>Interval in polling iterations to write checkpoints. A value of 0
		disables checkpoints</td>
	  </tr>
	  <tr>
		<td><code>weights</code></td>
		<td> Option&lt;Vec&lt;f64&gt;&gt;</td>
		<td>An optional sequence of atomic masses for use in normal coordinate
		QFFs and spectroscopic calculations</td>
	  </tr>
	  <tr>
		<td><code>dummy_atoms</code></td>
		<td> Option&lt;usize&gt;</td>
		<td>An optional number of trailing dummy atoms</td>
	  </tr>
	  <tr>
		<td><code>norm_resume_hff</code></td>
		<td>Option&lt;bool&gt;</td>
		<td>Resume a normal coordinate QFF from a previously-finished HFF
		checkpoint</td>
	  </tr>
	</table>

	<h3 id=geometry-specification-and-optimization><a href="#geometry-specification-and-optimization">Geometry Specification and Optimization</a></h3>

	<p>
	  The <code>geometry</code> can be specified as either an XYZ geometry with
	  an optional number of atoms and comment line or as a Z-matrix. Currently,
	  pbqff cannot automatically convert between Z-matrix and XYZ geometries,
	  so <code>optimize = true</code> is required if the geometry is provided as
	  a Z-matrix. This allows pbqff to extract the Cartesian geometry from the
	  quantum chemistry program's output file and use that for the geometrical
	  displacements. For completeness, here is an example XYZ geometry for
	  cyclopropenylidene:
	</p>

	<pre><code>5
c3h2 geometry
C          0.0000000000        0.0000000000       -0.8887390447
C          0.0000000000       -0.6627588746        0.3682596138
C          0.0000000000        0.6627588746        0.3682596138
H          0.0000000000       -1.5952720351        0.9069548903
H          0.0000000000        1.5952720351        0.9069548903
</code></pre>

	<p>
	  Again, the first two lines are optional, but if either one is present then
	  both must be present. And an example Z-matrix geometry for water:
	</p>

	<pre><code>O
H 1 OH
H 1 OH 2 HOH

OH = 1.0
HOH = 109.5
</code></pre>

	<p>
	  Aside from the caveats above about Z-matrix input,
	  the <code>optimize</code> keyword tells pbqff whether or not to optimize
	  the geometry before building the rest of the QFF. Because the quality of
	  the Taylor series approximation underlying the QFF is tied to the
	  assumption that the input geometry is a minimum on the potential energy
	  surface (PES), any geometries provided with <code>optimize = false</code>
	  should definitely have been optimized prior to the pbqff run and at the
	  same level of theory as the QFF.
	</p>

	<h3 id=charge><a href="#charge">Charge</a></h3>

	<p>
	  <code>charge</code> is possibly the most straightforward input option as
	  it is simply the molecular charge as a whole number. As we'll see in later
	  sections, this won't necessarily be used if you omit
	  a <code>{{.charge}}</code> entry in your program template, but the
	  option must be provided in the pbqff input file even in those cases.
	</p>

	<h3 id=step-size><a href="#step-size">Step Size</a></h3>

	<p>
	  <code>step_size</code> sets the displacement size for the QFF in units of
	  Ångstroms. 0.005 is a reasonable default, with larger values like 0.010 or
	  even 0.020 helping occasionally with floppy systems.
	</p>

	<h3 id=sleep-interval><a href="#sleep-interval">Sleep Interval</a></h3>

	<p>
	  pbqff uses a polling model for running jobs in parallel. On each iteration
	  of a big loop that runs until all jobs have finished, pbqff checks each
	  output file for the currently-running jobs to see if any have finished.
	  For very short single-point energy calculations (like PM6 or HF/STO-3G)
	  this makes a lot of sense because many jobs are likely to finish
	  constantly and each iteration will make some progress. On the other hand,
	  for long-running individual jobs (like CCSD(T)-F12/cc-pCVTZ-F12 on a large
	  molecule), pbqff will waste a lot of CPU time constantly checking the same
	  output files that may not have changed meaningfully since the last polling
	  interval. Thus, <code>sleep_int</code> is an interval in seconds for pbqff
	  to sleep between such polling attempts. Higher values should cause pbqff
	  to spend less CPU time reading the same files over and over, but extremely
	  high values could potentially lead to periods of no jobs running because
	  submitting more jobs as old ones finish is also part of the polling loop.
	  In practice, I usually use a minimum of 60 seconds for this and go up to
	  ~600 seconds for what I consider really long jobs. The options in the next
	  section also have some effect on what to choose here.
	</p>

	<h3 id=job-limit-and-chunk-size><a href="#job-limit-and-chunk-size">Job Limit and Chunk Size</a></h3>

	<p>
	  These two options, <code>job_limit</code> and <code>chunk_size</code> are
	  in the same section because they are very closely related. Early versions
	  of pbqff submitted each single-point energy calculation as a separate
	  queue submission limited by the <code>job_limit</code> setting. However,
	  this was inefficient enough to attract the attention of the HPC
	  administrators who recommended combining multiple program invocations into
	  a single submission script. This led to the addition of
	  the <code>chunk_size</code> option, which sets the number of invocations
	  per submission script (chunk). Hopefully this is already clear, but below
	  is an illustration of a chunk of MOPAC jobs for a local queue, where "job
	  submission" is handled by a very simple bash script. This would correspond
	  to a <code>chunk_size</code> of 5.
	</p>

	<pre><code>/opt/mopac/mopac job.0000000.mop
/opt/mopac/mopac job.0000001.mop
/opt/mopac/mopac job.0000002.mop
/opt/mopac/mopac job.0000003.mop
/opt/mopac/mopac job.0000004.mop
</code></pre>

	<p>
	  Because of this legacy, <code>job_limit</code> still corresponds to
	  individual calculations, despite the fact that they are now grouped into
	  chunks. As a result, if you want to restrict the number of jobs as
	  reported by your queue manager you should consider the
	  ratio <code>job_limit / chunk_size</code> rather
	  than <code>job_limit</code> alone. For example, to target a maximum number
	  of queued jobs of 500 with a chunk size of 25, you could set
	  a <code>job_limit</code> of <code>500 * 25 = 12_500</code>. Note the use
	  of the underscore as a digit separator. This is not required in TOML but
	  can be handy for large numbers.
	</p>

	<p>
	  The main consideration when choosing a <code>chunk_size</code> is the
	  amount of time spent submitting jobs versus actually running jobs.
	  According to our system administrators, the cutoff (likely pretty
	  conservative) is around 5 minutes of job time. This can lead to pretty
	  crazy chunk sizes, especially for PM6 calculations on small molecules,
	  where single-point energy computations can take on the order of 0.01
	  seconds (<code>5 minutes = 300 seconds | 1 job / 0.01 seconds => 30_000
	  jobs per chunk</code>!). However, more expensive calculations can easily
	  take five minutes or more each, allowing you to use a chunk size of 1.
	  Individual jobs give pbqff the greatest freedom to queue new jobs as old
	  ones finish, but, again, it's possible to spend more time writing and
	  submitting separate jobs (and taxing the queue system) than actually
	  running calculations.
	</p>

	<p>
	  Of course, the preceding paragraphs all assume that you're running pbqff
	  on a large molecule with many single-point calculations <i>and</i> that
	  you're on some kind of distributed compute cluster. If, on the other hand,
	  you're running pbqff on a personal computer or a single node on a cluster
	  using the local queue option, you will only be able to run a very small
	  number of chunks at once anyway (roughly one per CPU or thread you allowed
	  pbqff to use). In this case, there's no real incentive to shrink
	  your <code>chunk_size</code> to allow more flexible submission. As long as
	  your chunk size is small enough to send one chunk to each core you
	  requested, all of your compute will be saturated already. For example, you
	  wouldn't want to request a chunk size of 250 for a 1000-job QFF and
	  request 8 cores because only 4 cores would get chunks to work on, but
	  there's no real reason to set a chunk size of 25 either. It will just lead
	  to a lot more shell scripts being written. The logic is similar for a
	  small molecule like a diatomic where the total number of points may be
	  smaller than a reasonable chunk size for other calculations.
	</p>

	<h4 id=rules-of-thumb><a href="#rules-of-thumb">Rules of Thumb</a></h4>

	<p>
	  This table contains my general heuristics for <code>job_limit</code>
	  and <code>chunk_size</code> requests on our compute cluster, where the
	  hard limit on queued jobs is around 1000, but most of the time I can only
	  get ~50 jobs to run at once anyway.
	</p>

	<table>
	<tr>
<th>Level of Theory</th>
<th>Time Per Job (s)</th>
<th>Job Limit</th>
<th>Chunk Size</th>
</tr>
<tr>
<td>PM6 (5 atoms)</td>
<td>0.01</td>
<td>1_500_000</td>
<td>30_000</td>
</tr>
<tr>
<td>F12-DZ (5 atoms)</td>
<td> 1</td>
<td> 15_000</td>
<td> 300</td>
</tr>
<tr>
<td>TZ-cCR (8 atoms)</td>
<td> 300</td>
<td> 50</td>
<td> 1</td>
</tr>

	</table>

	<h3 id=coordinate-types><a href="#coordinate-types">Coordinate Types</a></h3>

	<p>
	  pbqff originally grew out of two separate projects: <code>go-cart</code>,
	  which was my first implementation of finite-difference
	  Cartesian-coordinate QFFs, and pbqff proper, which automated our group's
	  traditional least-squares fitted symmetry-internal coordinate (SIC) QFFs.
	  These two (SICs and Cartesian coordinates) are still supported, along with
	  the newest but already most-used normal-coordinate QFFs. Fully documenting
	  the construction of a symmetry-internal coordinate system is beyond the
	  scope of this manual (at least for now but likely forever) because it
	  involves a lot of practice and manual construction. Thus, the two
	  recommended coordinate systems for pbqff are Cartesian coordinates,
	  requested by <code>coord_type = "cart"</code> and normal coordinates,
	  requested by <code>coord_type = "norm"</code>.
	</p>

	<h4 id=cartesian-coordinates><a href="#cartesian-coordinates">Cartesian Coordinates</a></h4>

	<p>
	  Cartesian coordinates are the most straightforward coordinate system. The
	  initial geometry is either already in Cartesian (XYZ) form or can be
	  converted from a Z-matrix by the quantum chemistry program. Then, each of
	  these coordinates is displaced in all of the two-, three-, and
	  four-coordinate combinations needed to map out the QFF. It is
	  theoretically possible to approximate the PES with a least-squares fit in
	  Cartesian coordinates, but this is not currently implemented. I tried this
	  in a previous version of pbqff, and it led to significant bottlenecks in
	  the least-squares fit due to the much larger number of Cartesian points
	  compared to SICs without any improvement (and occasional worsening) of the
	  results. In other words, Cartesian coordinates imply <code>findiff =
	  true</code>.
	</p>

	<h4 id=normal-coordinates><a href="#normal-coordinates">Normal Coordinates</a></h4>

	<p>
	  Normal coordinates are generally a clear improvement over Cartesian
	  coordinates. First, the VPT2 implementation in spectro only requires the
	  semi-diagonal normal coordinate force constants (Φ<sub>iijj</sub> and
	  Φ<sub>iiii</sub>), but these require the fully-off-diagonal Cartesian
	  coordinate force constants like F<sub>ijkl</sub> to compute. Similarly,
	  and even more straightforwardly, normal coordinates discard the rotational
	  and translational degrees of freedom present in Cartesian coordinates,
	  lowering the number of coordinates from <code>3N</code> to <code>3N
	  &minus; 6</code>. Combined, these factors allow for far fewer single-point
	  energies to be evaluated in normal coordinates.
	</p>

	<p>
	  Further, normal coordinates share the convenience of Cartesian
	  coordinates: they can be derived automatically from the input geometry.
	  This may not be clear from this manual because of the limited treatment of
	  SICs, but this is the primary contrast between SICs and normal coordinates
	  because SICs also require far fewer points than Cartesians, putting them
	  on more equal footing with normal coordinates in terms of computational
	  cost (but still worse for even medium-sized molecules) but certainly not
	  in convenience.
	</p>

	<p>
	  Of course, the similarity to Cartesian coordinates is no accident. Normal
	  coordinates can only be derived automatically by computing a Cartesian
	  harmonic force field (HFF) to obtain the Hessian matrix, from which the
	  mass-weighted eigenvalues can be extracted to yield the normal
	  coordinates. This separation of the HFF and QFF leads to two additional
	  options for normal coordinate QFFs: <code>hybrid_template</code>
	  and <code>norm_resume_hff</code>. These are both discussed more fully in
	  later sections, but in brief, <code>hybrid_template</code> allows you to
	  use the plain <code>template</code> as the template for the HFF points and
	  the <code>hybrid_template</code> for the cubic and quartic points;
	  and <code>norm_resume_hff</code> allows you to resume a normal coordinate
	  QFF from a checkpoint after the initial HFF.
	</p>

	<p>
	  Normal coordinates are also the only coordinate type for which
	  the <code>findiff</code> option actually has any effect. SICs are assumed
	  to be fitted (<code>findiff = false</code>) and Cartesians are assumed to
	  be finite-difference. However, because of the way normal coordinates are
	  constructed (via the initial HFF), fitted normal coordinates are not refit
	  to zero the approximated function gradient as was typical with SICs.
	  Again, this is likely not to make much sense unless you're familiar with
	  the SIC procedure itself, but in short, this means normal coordinates
	  don't really capture the benefits SICs got from performing this fitting,
	  and finite differences are more economical, so stick with finite
	  differences (<code>findiff = true</code>) unless you really know what
	  you're doing.
	</p>

	<p>
	  Finally, normal coordinates are not without their limitations. Their main
	  shortcoming relates to the mass-weighting involved in their definition,
	  which causes the atomic masses to be baked into the resulting force
	  constants in a way that is not easy to reverse. Practically, this means
	  that computing isotopic spectroscopic data with normal coordinate QFFs
	  requires recomputing the QFF for each combination
	  of <a href="#atomic-masses">atomic masses</a>. Second, because they are
	  based on the Cartesian HFF, any numerical issues in the initial HFF can be
	  dramatically compounded in the QFF. This mostly arises with highly
	  symmetrical molecules (symmetric and spherical tops) with many resonances,
	  but it can also pop up for other tricky molecules. It should be pretty
	  obvious when this happens (anharmonic frequencies of 10,000 or more), but
	  it's something to keep in the back of your mind.
	</p>

	<h4 id=symmetry-internal-coordinates><a href="#symmetry-internal-coordinates">Symmetry-Internal Coordinates</a></h4>

	<p>
	  As mentioned above, fully documenting the SIC code could double the size
	  of this document. All I'll say here is that running an SIC QFF in pbqff
	  requires the top of an INTDER input file (the simple- and
	  symmetry-internal coordinate definitions) in a file
	  named <code>intder.in</code> in the directory where you invoke pbqff. If
	  there's a resurgence of interest in SICs, I'd like to handle this kind of
	  input in a more compact way and without requiring a separate file. Feel
	  free to send me an email or open a GitHub issue if you are interested in
	  this or try using it and encounter any problems.
	</p>

	<h3 id=quantum-chemistry-program-types><a href="#quantum-chemistry-program-types">Quantum Chemistry Program Types</a></h3>

	<p>
	</p>

	<h3 id=queue-types><a href="#queue-types">Queue Types</a></h3>

	<p>
	</p>

	<h3 id=quantum-chemistry-program-templates><a href="#quantum-chemistry-program-templates">Quantum Chemistry Program Templates</a></h3>

	<p>
	</p>

	<h3 id=queue-templates><a href="#queue-templates">Queue Templates</a></h3>

	<p>
	</p>

	<h3 id=derivative-types><a href="#derivative-types">Derivative Types</a></h3>

	<p>
	</p>

	<h3 id=checkpoints><a href="#checkpoints">Checkpoints</a></h3>

	<p>
	</p>

	<h3 id=atomic-masses><a href="#atomic-masses">Atomic Masses</a></h3>

	<p>
	</p>

	<h3 id=dummy-atoms><a href="#dummy-atoms">Dummy Atoms</a></h3>

	<p>
	</p>

	<h3 id=resuming-normal-coordinate-qffs><a href="#resuming-normal-coordinate-qffs">Resuming Normal Coordinate QFFs</a></h3>

	<p>
	</p>

	<h2 id=command-line-options><a href="#command-line-options">Command Line Options</a></h2>

	<p>
	  In addition to the settings in the input file described in the previous
	  section, pbqff takes several command line options. To some extent, the
	  most important of these is the name of the input file, but even this has a
	  default value of <code>pbqff.toml</code>, allowing it to be omitted if you
	  use that as your input file name. The other options are summarized in the
	  table below.
	</p>

	<table>
	  <caption>Summary of command line options</caption>
	  <tr>
<th>Option</th>
<th>Type</th>
<th>Description</th>
</tr>
<tr>
<td><nobr><code>-c/--checkpoint</nobr></code></td>
<td>bool</td>
<td>Resume from the checkpoint files in the current directory (chk.json and res.chk). Defaults to false.</td>
</tr>
<tr>
<td><nobr><code>-o/--overwrite</nobr></code></td>
<td>bool</td>
<td>Overwrite existing output from a previous run. Defaults to false.</td>
</tr>
<tr>
<td><nobr><code>-v/--version</nobr></code></td>
<td>bool</td>
<td>Print the git commit hash and exit. Defaults to false.</td>
</tr>
<tr>
<td><nobr><code>-t/--threads</nobr></code></td>
<td>usize</td>
<td>Set the maximum number of threads to use. Defaults to 0, which means to use as many threads as there are CPUS.</td>
</tr>
<tr>
<td><nobr><code>-j/--json</nobr></code></td>
<td>bool</td>
<td>Serialize the input file to JSON and exit. For use by qffbuddy.</td>
</tr>
<tr>
<td><nobr><code>-n/--no_del</nobr></code></td>
<td>bool</td>
<td>Don't delete any files when running the single-point energies. Defaults to false.</td>
</tr>

	</table>

	<p>
	  As indicated by the slash, each of these options can either be provided as
	  a short option with a single dash and its first letter or as a long option
	  with two dashes and the full name.
	</p>

	<p>
	  Of these options, <code>-t/--threads</code> is probably the most important
	  on a regular basis since it controls the number of threads spawned by
	  pbqff. If you're running pbqff on a local computer, you may want to limit
	  this to ~half of the CPUs on the machine to allow other programs to run
	  smoothly. Otherwise, if you're running pbqff on some kind of HPC cluster,
	  you'll likely want to set this to the number of CPUs you request in your
	  job submission script.
	</p>

	<p>
	  The <code>-o/--overwrite</code> option is also commonly used, especially
	  if you make a typo in your first submission of a pbqff job. By default,
	  pbqff will refuse to overwrite any output files in the current directory,
	  even if they just contain an error message. Passing the <code>-o</code>
	  flag will bypass this check and allow the run to continue.
	</p>

	<p>
	  The <code>-c/--checkpoint</code> flag can be used to resume from a
	  previously-written checkpoint file. See
	  the <a href="#checkpoints">Checkpoints</a> section above for more details.
	</p>

	<p>
	  Finally, the <code>-n/--no_del</code> option prevents pbqff from cleaning
	  up the (sometimes numerous) single-point energy input and output files as
	  it runs. This is primarily useful if you're debugging some kind of issue
	  in pbqff and need to see all of the output files at the end of a run. This
	  is not the default because large QFFs produce a very large quantity of
	  very similar files that HPC administrators don't always like to keep
	  around.
	</p>

	<p>
	  As noted in the table, the <code>-j/--json</code> flag is intended
	  primarily for use by qffbuddy and is hidden from the
	  built-in <code>-h/--help</code> flag contained in pbqff. However, it is
	  documented here in case it proves useful for other interfaces to pbqff.
	</p>

  </body>
</html>
